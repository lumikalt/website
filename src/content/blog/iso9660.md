---
title: ISO 9660
description: Implementing a File System for ISO/IEC 9660:2023
date: 2026.01.09
latex: true
---

Note: this post is written formally.

## Introduction

ISO 9960 is the standard that describes how data is stored in a variety of physical formats, including the CD-ROM. It was first standardized as ISO/IEC 10149 in 1989 and ISO 9660 in 1988 for the data-interchange, and volume and file structure, respectively.

Since ISO 9660\:1988, two Amendments were issued in 2013 and 2020 to include the Joliet Specialization.

Now, ISO 9660\:2023 makes ISO/IEC 10149 the normative reference specifying recording and addressing methods for the compact disk, also consolidating the two Amendments.

## Blocks

Firstly, let's implement a `BlockDevice` that reads chunks off the ISO.

```rs
pub struct BlockDevice {
  file: File,
  ///  DVD-Video mandates 2048, but not ISO9660.
  pub block_size: u16,
}

impl BlockDevice {
  pub fn open(path: impl AsRef<Path>) -> io::Result<Self>
  pub fn read_block(&mut self, lba: u32) -> io::Result<Vec<u8>>
}
```

This struct contains the file handle to our working ISO file, along with the block size. While the ultimate goal is to write a DVD player, and the DVD-Video standard does mandate blocks of 2048 bytes, this toy implementation should still do the bare minimum.

It has two member functions. `open()` takes the path to an ISO file, just like `std::fs::File::open()`. According to the standard, we have the following structure to the storage sectors:

| Sector | Purpose                                |
| :----- | :------------------------------------- |
| 0..=15 | Reserved                               |
| 16     | Primary Volume Descriptor              |
| 17..   | Supplementary / Partition / Terminator |

Of course, being able to find the PVD without knowing the block size is impossible. As such, ISO 9660 mandates that Volume Descriptors are at offsets equal to 16 \* 2048.

| Offset  | Size | Purpose            |
| :------ | :--- | :----------------- |
| 128,129 | 16   | Logical Block (LE) |
| 130,131 | 16   | Logical Block (BE) |

The reader may be asking: "Why is this even stored in two endian formats?" The answer is in Section 8.2 of the standard. 16-bit numerical values may be stored in one of three formats, specified in the description of the descriptor fields.
These are:

- Least significant byte first, also known as Little Endian. The value 4660 = 0x1234 is stored as [0x34, 0x12].
- Most significant byte first, aka Big Endian. That same value is stored as [0x12, 0x34].
- Both-byte orders. In this case, we store it as both formats, first LE then BE, ending up with [0x34, 0x12 0x12 0x34].

Indeed, the block size is in the third format.

So, here's `open()`.

```rs
pub fn open(path: impl AsRef<Path>) -> io::Result<Self> {
  let mut file = File::open(path)?;
  let mut pvd = [0u8; 2048];

  file.seek(SeekFrom::Start(16 * 2048))?;
  file.read_exact(&mut pvd)?;

  let block_size = u16::from_le_bytes([pvd[128], pvd[129]]);

  Ok(Self { file, block_size })
}
```

Now that the block size is known, the file is traversable. So, here's `read_block()`.

```rs
pub fn read_block(&mut self, lba: u32) -> io::Result<Vec<u8>> {
  let mut buf = vec![0u8; self.block_size as usize];
  self.file
      .seek(SeekFrom::Start(lba as u64 * self.block_size as u64))?;
  self.file.read_exact(&mut buf)?;
  Ok(buf)
}
```

## Directories

Next, let's look at how directories and files are arranged on the disk. Section 8.6 describes directories, 8.5 describes files. Identifiers are described in terms of Section 8.4: Character sets and encoding, but let's ignore that for now.

For directories, the identifier, i.e. the directory name, shall be a string, with a max length of 31, for the PVD and SVD (Supplementary Volume Descriptor), or 207, for an Enhanced Volume Descriptor.

For files, it consists of the following sequence:

- File name: sequence of 0 or more characters;
- Separator 1;
- File name extension: sequence of 0 or more characters;
- separator 2;
- File version number: digits from 1 to 32.767.

For PVD and SVD, the sum of the file name length and extension length cannot be 0 (i.e. at least one must be higher than 0) and cannot exceed 30.
For EVD, the file name length cannot exceed 207, no separators are specified, no file name extension is defined and no file name version is present.

Note: 207 is 254 (max directory record length) minus 33 (min length of directory record excluding file identifier) minus 14 (CD-ROM XA system use extension information).

Worth noting that there are two special, reserved directory identifiers: the single-byte identifiers 0x00 and 0x01, standing for `.` and `..`, respectively.

```rs
#[derive(Debug, Clone)]
pub struct DirEntry {
    pub name: String,
    pub lba: u32,
    pub size: u32,
    pub is_dir: bool,
}

#[derive(Debug, Clone)]
pub struct Directory {
    pub entries: Vec<DirEntry>,
}
```

```rs
pub fn parse_directory(data: &[u8]) -> Vec<DirEntry> {
    let mut pos = 0;
    let mut entries = vec![];

    while pos < data.len() {
        let len = data[pos];
        if len == 0 {
            pos = ((pos / 2048) + 1) * 2048;
            continue;
        }

        let rec = &data[pos..pos + len as usize];

        let lba = u32::from_le_bytes(rec[2..6].try_into().unwrap());
        let size = u32::from_le_bytes(rec[10..14].try_into().unwrap());
        let flags = rec[25];
        let name_len = rec[32] as usize;
        let name = String::from_utf8_lossy(&rec[33..33 + name_len]).to_string();

        if name != "\u{0}" && name != "\u{1}" {
            entries.push(DirEntry {
                name: name.split(';').next().unwrap().to_string(),
                lba,
                size,
                is_dir: flags & 0x02 != 0,
            });
        }

        pos += len as usize;
    }

    entries
}
```
